/*
	Copyright 2020. (노성철, nsch78@nate.com, nsch@naver.com) All right reserved
*/
package ipv4

/*
import . "unsafe"
import . "console"
*/
import . "unsafe"
import . "util"
import . "콘솔"
import . "net/etherframe"
import . "net/arp"

var ip콘솔 T콘솔 = T콘솔{}
////////////////////////////////////////////////////////////////////
//
//	상호통신규약 = 인터넷규약 = InternetProtocol = IP
//
////////////////////////////////////////////////////////////////////
type T인터넷규약V4_메시지_임시저장공간 struct{
	길이_버전 byte			// versin and length
	서비스유형 byte			// type of service
	전체길이 [2]byte		// total length
	
	식별자 [2] byte			// identification
	분열특성_분열위치 [2] byte	// flags and fragment offset
	
	수명 byte			// time to live
	규약 byte			// protocol
	검사합 [2] byte			// checksum
	
	출발지_아이피 [4] byte		// source ip address
	목적지_아이피 [4] byte		// destination ip address
}
var 인터넷규약_머리말_길이 uint8 = (4+4+4+8)
type T인터넷규약V4_메시지 struct{
	머리말_길이 uint8		// header length
	버전 uint8			// version
	서비스유형 uint8		// type of service
	전체길이 uint16			// total length

	식별자 uint16			// identification
	분열특성_분열위치 uint16	// flags and fragment offset
	
	수명 uint8			// time to live
	규약 uint8			// protocol
	검사합 uint16			// checksum

	출발지_아이피 uint32		// source ip address
	목적지_아이피 uint32		// destination ip address
}
func (자신 *T인터넷규약V4_메시지) M초기화(임시저장공간 *T인터넷규약V4_메시지_임시저장공간){
	자신.버전 = ((임시저장공간.길이_버전 & 0xF0) >> 4)
	자신.머리말_길이 = 임시저장공간.길이_버전 & 0x0F
	자신.서비스유형 = 임시저장공간.서비스유형
	자신.전체길이 = Uint16_R(ArrayToUint16(임시저장공간.전체길이))

	자신.식별자 = Uint16_R(ArrayToUint16(임시저장공간.식별자))
	자신.분열특성_분열위치 = Uint16_R(ArrayToUint16(임시저장공간.분열특성_분열위치))
	
	자신.수명 = 임시저장공간.수명
	자신.규약 = 임시저장공간.규약
	자신.검사합 = Uint16_R(ArrayToUint16(임시저장공간.검사합))

	자신.출발지_아이피 = Uint32_R(ArrayToUint32(임시저장공간.출발지_아이피))
	자신.목적지_아이피 = Uint32_R(ArrayToUint32(임시저장공간.목적지_아이피))

}
func (자신 *T인터넷규약V4_메시지) M버퍼설정(임시저장공간 *T인터넷규약V4_메시지_임시저장공간){
	임시저장공간.길이_버전 = byte(((자신.버전 & 0x0F) << 4) | (자신.머리말_길이 & 0x0F))
	임시저장공간.서비스유형 = 자신.서비스유형
	임시저장공간.전체길이 = Uint16ToArray(자신.전체길이)

	임시저장공간.식별자 = Uint16ToArray(자신.식별자)
	임시저장공간.분열특성_분열위치 = Uint16ToArray(자신.분열특성_분열위치)

	임시저장공간.수명 = 자신.수명
	임시저장공간.규약 = 자신.규약
	임시저장공간.검사합 = Uint16ToArray(자신.검사합)

	임시저장공간.출발지_아이피 = Uint32ToArray(자신.출발지_아이피)
	임시저장공간.목적지_아이피 = Uint32ToArray(자신.목적지_아이피)
	
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
type I인터넷규약_처리기 interface{
	M인터넷규약_받은동시(출발지_아이피_BE uint32, 목적지_아이피_BE uint32, 자료주소 uintptr, 크기 uint32) bool
	M패킷보내기(목적지_아이피_BE uint32, p_규약 uint8, 자료주소 uintptr, 크기 uint32)
	M제공자_갖기() *T인터넷규약_제공자
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
type T인터넷규약_처리기_자료 struct{
	후단부 T인터넷규약_제공자
	규약 uint8
}
var 처리기_자료 T인터넷규약_처리기_자료

type T인터넷규약_처리기 struct{
}
func (자신 *T인터넷규약_처리기) M초기화(후단부 T인터넷규약_제공자, 인터넷규약_처리기 I인터넷규약_처리기, 규약 uint8){
	처리기_자료.규약 = 규약
	처리기_자료.후단부 = 후단부
	자료.인터넷규약_처리기들[규약] = 인터넷규약_처리기
}
func (자신 *T인터넷규약_처리기) M인터넷규약_받은동시(출발지_아이피_BE uint32, 목적지_아이피_BE uint32, 자료주소 uintptr, 크기 uint32) bool{
	return false
}
func (자신 *T인터넷규약_처리기) M패킷보내기(목적지_아이피_BE uint32, 규약 uint8, 자료주소 uintptr, 크기 uint32){
	처리기_자료.후단부.M패킷보내기(목적지_아이피_BE, 규약, 자료주소, 크기)
}
func (자신 *T인터넷규약_처리기) M제공자_갖기() *T인터넷규약_제공자 {
	return &처리기_자료.후단부
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
type T인터넷규약_제공자_자료 struct{
	주소결정규약_제공자 T주소결정규약_제공자
	게이트웨이_아이피 uint32
	서브넷마스크 uint32
	인터넷규약_처리기들 [255] I인터넷규약_처리기
}
var 자료 T인터넷규약_제공자_자료

type T인터넷규약_제공자 struct{
	T이더넷프레임_처리기
}

func (자신 *T인터넷규약_제공자) M초기화(후단부 T이더넷프레임_제공자)	{

	자신.T이더넷프레임_처리기.M초기화(후단부)
	자신.T이더넷프레임_처리기.M처리기설정(자신, 0x0800)
	
	for i:=0; i<255; i++ {
		 자료.인터넷규약_처리기들[i] = nil
	}
	
}
func (자신 *T인터넷규약_제공자) M주소설정(주소결정규약_제공자 T주소결정규약_제공자, 게이트웨이_아이피 uint32, 서브넷마스크 uint32){
	자료.주소결정규약_제공자 = 주소결정규약_제공자
	자료.게이트웨이_아이피 = 게이트웨이_아이피
	자료.서브넷마스크 = 서브넷마스크
}
func (자신 *T인터넷규약_제공자) M이더넷프레임_받는동시(이더넷프레임_페이로드 uintptr, 크기 uint32) bool{
	if 크기 < uint32(인터넷규약_머리말_길이) {
		return false
	}
	
	var 임시저장공간 *T인터넷규약V4_메시지_임시저장공간 = (*T인터넷규약V4_메시지_임시저장공간)(Pointer(이더넷프레임_페이로드))
	var 아이피메시지 T인터넷규약V4_메시지
	아이피메시지.M초기화(임시저장공간)

	var sendBack bool = false

	if 아이피메시지.목적지_아이피 == uint32(자신.M아이피주소_갖기()) {

		var 길이 uint32 = uint32(아이피메시지.전체길이)
		if 길이 > 크기 {
			길이 = 크기
		}
		if 자료.인터넷규약_처리기들[아이피메시지.규약] != nil {
			sendBack  = 자료.인터넷규약_처리기들[아이피메시지.규약].M인터넷규약_받은동시(아이피메시지.출발지_아이피, 
									아이피메시지.목적지_아이피, 
									이더넷프레임_페이로드 + uintptr(4*아이피메시지.머리말_길이), 
									uint32(길이-uint32(4*아이피메시지.머리말_길이)))

		}
	}

	if(sendBack) {
		var 임시 = 아이피메시지.목적지_아이피
		아이피메시지.목적지_아이피 = 아이피메시지.출발지_아이피
		아이피메시지.출발지_아이피 = 임시

		아이피메시지.수명 = 0x40
		아이피메시지.검사합 = 0
		
		아이피메시지.M버퍼설정(임시저장공간)
		아이피메시지.검사합 = 자신.M검사합((*([4096]uint16))(Pointer(이더넷프레임_페이로드)), uint32(4*아이피메시지.머리말_길이))
		아이피메시지.M버퍼설정(임시저장공간)

	}

	return sendBack

}
func (자신 *T인터넷규약_제공자) M패킷보내기(목적지_아이피_BE uint32, 규약 uint8, 자료주소 uintptr, 크기 uint32) {
	var 임시저장공간1 [4096] byte
	var 임시저장공간 *T인터넷규약V4_메시지_임시저장공간 = (*T인터넷규약V4_메시지_임시저장공간)(Pointer(&임시저장공간1))
	var 아이피메시지 T인터넷규약V4_메시지  = T인터넷규약V4_메시지{}
	아이피메시지.버전 = 4
	아이피메시지.머리말_길이 = 인터넷규약_머리말_길이/4
	아이피메시지.서비스유형 = 0
	아이피메시지.전체길이 = Uint16_R(uint16(크기 + uint32(인터넷규약_머리말_길이)))

	아이피메시지.식별자 = 0x0100
	아이피메시지.분열특성_분열위치 = 0x0040
	아이피메시지.수명 = 0x40
	아이피메시지.규약 = 규약
	
	아이피메시지.목적지_아이피 = 목적지_아이피_BE

	아이피메시지.출발지_아이피 = uint32(자신.M아이피주소_갖기())

	아이피메시지.검사합 = 0

	아이피메시지.M버퍼설정(임시저장공간)
	아이피메시지.검사합 = 자신.M검사합((*([4096]uint16))(Pointer(&임시저장공간1)), uint32(인터넷규약_머리말_길이))
	아이피메시지.M버퍼설정(임시저장공간)

	var data임시저장공간 [4096] byte = *(*([4096]byte))(Pointer(자료주소))
	for i:=0; i<int(크기); i++ {
		임시저장공간1[i+int(인터넷규약_머리말_길이)] = data임시저장공간[i]
	}

	var 라우터 uint32 = 목적지_아이피_BE
	if (목적지_아이피_BE & 자료.서브넷마스크) != (아이피메시지.출발지_아이피 & 자료.서브넷마스크) {
		라우터 = 자료.게이트웨이_아이피
	}

	var 보낼자료주소 = uintptr(Pointer(&임시저장공간1))

	var 이더넷타입_BE = Uint16_R(0x0800)
	자신.M이더넷프레임_보내기(자료.주소결정규약_제공자.Resolve(라우터), 
							이더넷타입_BE, 
							보낼자료주소, 
							uint32(인터넷규약_머리말_길이)+uint32(크기))
}
func (자신 *T인터넷규약_제공자) M검사합(p_자료 *[4096]uint16, lengthInBytes uint32) uint16{
	var 자료 [4096] uint16 = *p_자료

	var 임시 uint32 = 0
	for i:=0; i<int(lengthInBytes/2); i++ {
		임시 += uint32(Uint16_R(자료[i]))
	}
	var 자료바이트들 [4096] byte = *(*([4096]byte))(Pointer(&자료))
	if (lengthInBytes%2) !=0 {
		임시 += uint32(uint16(자료바이트들[lengthInBytes-1]) << 8)
	}

	for (임시 & 0xFFFF0000) != 0 {
		임시 = (임시 & 0xFFFF) + (임시 >> 16)
	}

	return uint16(((^임시 & 0xFF00) >> 8) | ((^임시 & 0x00FF) << 8))
}
func (자신 *T인터넷규약_제공자) M아이피주소_갖기() uint64{
        return 자신.T이더넷프레임_처리기.M아이피주소_갖기()
}

