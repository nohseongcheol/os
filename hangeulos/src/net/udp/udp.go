/*
	Copyright 2020. (노성철, nsch78@nate.com, nsch@naver.com) All right reserved
*/
package udp

import . "unsafe"
import . "콘솔"
import . "util"
import . "memorymanager"
import . "net/ipv4"


///////////////////////////////////////////////////////////////////////////
var 콘솔 = T콘솔{}
///////////////////////////////////////////////////////////////////////////
//
//		사용자데이터그램프로토콜 = UserDatagram Protocol = UDP
//		포트 = Port
//		사용자데이터그램프로토콜_소켓 = UserDatagramProtocolSocket = UDPSocket
//		수신대기 = Listen
//		결합하기 = Bind
//
///////////////////////////////////////////////////////////////////////////
type T사용자데이터그램프로토콜_머리말_임시저장공간 struct{
	출발지_포트번호 [2]byte
	목적지_포트번호 [2]byte

	길이 [2]byte
	검사합 [2]byte
}
var 사용자규약_머리글_크기 uint32 = 8
type T사용자데이터그램프로토콜_머리말 struct{
	출발지_포트번호 uint16
	목적지_포트번호 uint16

	길이 uint16
	검사합 uint16
}
func (자신 *T사용자데이터그램프로토콜_머리말) M초기화(임시저장공간 *T사용자데이터그램프로토콜_머리말_임시저장공간){
	자신.출발지_포트번호 = ArrayToUint16(임시저장공간.출발지_포트번호)
	자신.목적지_포트번호 = ArrayToUint16(임시저장공간.목적지_포트번호)
	
	자신.길이 = ArrayToUint16(임시저장공간.길이)
	자신.검사합 = ArrayToUint16(임시저장공간.검사합)
}
func (자신 *T사용자데이터그램프로토콜_머리말) M버퍼설정(임시저장공간 *T사용자데이터그램프로토콜_머리말_임시저장공간){

	임시저장공간.출발지_포트번호 = Uint16ToArray(자신.출발지_포트번호)
	임시저장공간.목적지_포트번호 = Uint16ToArray(자신.목적지_포트번호)

	임시저장공간.길이 = Uint16ToArray(자신.길이)
	임시저장공간.검사합 = Uint16ToArray(자신.검사합)

}

///////////////////////////////////////////////////////////////////////////
type I사용자데이터그램프로토콜_처리기 interface{
	M사용자데이터그램프로토콜_메시지_처리(소켓 *T사용자데이터그램프로토콜_소켓, 자료 uintptr, 크기 uint16)
}
///////////////////////////////////////////////////////////////////////////
type T사용자데이터그램프로토콜_처리기 struct{
}
func (자신 *T사용자데이터그램프로토콜_처리기) M초기화(backend T인터넷규약_제공자) {
}
func (자신 *T사용자데이터그램프로토콜_처리기) M사용자데이터그램프로토콜_메시지_처리(소켓 *T사용자데이터그램프로토콜_소켓, 자료 uintptr, 크기 uint16){
}

///////////////////////////////////////////////////////////////////////////
type I사용자데이터그램프로토콜_소켓 interface{
	M사용자데이터그램프로토콜_메시지_처리(자료 uintptr, 크기 uint16)
}
type T사용자데이터그램프로토콜_소켓 struct{
	원격포트번호 uint16
	원격아이피_주소 uint32
	자신포트번호 uint16
	자신아이피_주소 uint32

	리스닝 bool

	P사용자데이터그램프로토콜_제공자 T사용자데이터그램프로토콜_제공자
	P사용자데이터그램프로토콜_처리기 I사용자데이터그램프로토콜_처리기
}
func (자신 *T사용자데이터그램프로토콜_소켓) M초기화(p_사용자데이터그램프로토콜_제공자 T사용자데이터그램프로토콜_제공자){

	자신.P사용자데이터그램프로토콜_제공자 = p_사용자데이터그램프로토콜_제공자
	자신.리스닝 = false
}
func (자신 *T사용자데이터그램프로토콜_소켓) M사용자데이터그램프로토콜_메시지_처리(자료 uintptr, 크기 uint16){

	if 자신.P사용자데이터그램프로토콜_처리기 != nil {
		자신.P사용자데이터그램프로토콜_처리기.M사용자데이터그램프로토콜_메시지_처리(자신, 자료, 크기)
	}	
}
func (자신 *T사용자데이터그램프로토콜_소켓) M보내기(p_자료 []byte, 크기 uint16){
	var 임시저장공간 [4096] byte
	for i:=0; i<int(크기); i++ {
		임시저장공간[i] = p_자료[i]
	}
	var 자료 = uintptr(Pointer(&임시저장공간))
	자신.P사용자데이터그램프로토콜_제공자.M보내기(자신, 자료, 크기)
}
func (자신 *T사용자데이터그램프로토콜_소켓) M연결끊기(){
	자신.P사용자데이터그램프로토콜_제공자.M연결끊기(자신)
}
///////////////////////////////////////////////////////////////////////////
type T사용자데이터그램프로토콜_제공자_자료 struct{
	소켓들 [65535] T사용자데이터그램프로토콜_소켓
	소켓들_갯수 int
	여유포트번호 uint16
}
var 자료 T사용자데이터그램프로토콜_제공자_자료
type T사용자데이터그램프로토콜_제공자 struct{
	T인터넷규약_처리기
}

func (자신 *T사용자데이터그램프로토콜_제공자) M초기화(p_ipProvider T인터넷규약_제공자){
	자신.T인터넷규약_처리기.M초기화(p_ipProvider, 자신, 0x11)
	자료.소켓들_갯수 = 0
	자료.여유포트번호 = 1024
}
func (자신 *T사용자데이터그램프로토콜_제공자) M인터넷규약_받은동시(출발지아이피_BE uint32, 목적지아이피_BE uint32, 인터넷프로토콜_페이로드 uintptr, 크기 uint32) bool{
	if 크기 < 사용자규약_머리글_크기 {
		return false
	}
	
	var 임시저장공간 *T사용자데이터그램프로토콜_머리말_임시저장공간 = (*T사용자데이터그램프로토콜_머리말_임시저장공간)(Pointer(인터넷프로토콜_페이로드))
	var 머리말 T사용자데이터그램프로토콜_머리말
	머리말.M초기화(임시저장공간)


	var 소켓 *T사용자데이터그램프로토콜_소켓 = nil
	
	for i:=0; i<자료.소켓들_갯수 && 소켓==nil; i++ {

		if 자료.소켓들[i].자신포트번호 == 머리말.목적지_포트번호 && 
		   자료.소켓들[i].자신아이피_주소 == 목적지아이피_BE && 
		   자료.소켓들[i].리스닝 == true 	{

			소켓 = &자료.소켓들[i]
			소켓.리스닝 = false
			소켓.원격포트번호 = 머리말.출발지_포트번호
			소켓.원격아이피_주소 = 출발지아이피_BE

		}else if 자료.소켓들[i].자신포트번호 == 머리말.목적지_포트번호 && 
		  자료.소켓들[i].자신아이피_주소 == 목적지아이피_BE && 
		  자료.소켓들[i].원격포트번호 == 머리말.출발지_포트번호 && 
		  자료.소켓들[i].원격아이피_주소 == 출발지아이피_BE	{

			소켓 = &자료.소켓들[i]
	
		}
	}
	
	머리말.M버퍼설정(임시저장공간)
	if 소켓 != nil {
		소켓.M사용자데이터그램프로토콜_메시지_처리(인터넷프로토콜_페이로드 + uintptr(사용자규약_머리글_크기), uint16(크기 - 사용자규약_머리글_크기))
	}

	return false
}

func (자신 *T사용자데이터그램프로토콜_제공자) M연결하기(아이피 uint32, 포트 uint16) *T사용자데이터그램프로토콜_소켓{
	var memoryManager = &T메모리_관리자{}
	var 소켓 = (*T사용자데이터그램프로토콜_소켓)(memoryManager.Malloc(50))

	if 소켓 != nil {
		
		소켓.M초기화(*자신)
		소켓.원격포트번호 = 포트
		소켓.원격아이피_주소 = 아이피
		소켓.자신포트번호 = 자료.여유포트번호 
		자료.여유포트번호++
		소켓.자신아이피_주소 = uint32((*자신.T인터넷규약_처리기.M제공자_갖기()).M아이피주소_갖기())

		소켓.원격포트번호 = Uint16_R(소켓.원격포트번호)
		소켓.자신포트번호 = Uint16_R(소켓.자신포트번호)
		
		자료.소켓들[자료.소켓들_갯수] = *소켓
		자료.소켓들_갯수++

	}
	return 소켓
	
}
func (자신 *T사용자데이터그램프로토콜_제공자) M수신대기(포트 uint16) *T사용자데이터그램프로토콜_소켓{
	var memoryManager = &T메모리_관리자{}
	var 소켓 = (*T사용자데이터그램프로토콜_소켓)(memoryManager.Malloc(50))
	if 소켓 != nil {
		소켓.M초기화(*자신)
		소켓.리스닝 = true
		소켓.자신포트번호 = 포트
		소켓.자신아이피_주소 = uint32((*자신.T인터넷규약_처리기.M제공자_갖기()).M아이피주소_갖기())

		소켓.자신포트번호 = Uint16_R(소켓.자신포트번호)
	}
	return 소켓
}
func (자신 *T사용자데이터그램프로토콜_제공자) M연결끊기(소켓 *T사용자데이터그램프로토콜_소켓){
	for i:=0; i< 자료.소켓들_갯수 && 소켓==nil; i++ {
		if 자료.소켓들[i] == *소켓 {
			자료.소켓들_갯수--
			자료.소켓들[i] = 자료.소켓들[자료.소켓들_갯수]
			break
		}
	}
}
func (자신 *T사용자데이터그램프로토콜_제공자) M보내기(소켓 *T사용자데이터그램프로토콜_소켓, p_자료 uintptr, 크기 uint16){
	var 전체길이 = uint32(크기) + 사용자규약_머리글_크기
	
	var 임시저장공간 [4096]byte
	var 머리말_임시저장공간 = (*T사용자데이터그램프로토콜_머리말_임시저장공간)(Pointer(&임시저장공간))
	
	var 머리말 = T사용자데이터그램프로토콜_머리말{}

	머리말.출발지_포트번호 = 소켓.자신포트번호
	머리말.목적지_포트번호 = 소켓.원격포트번호
	머리말.길이 = Uint16_R(uint16(전체길이))

	머리말.검사합 = 0x0
	머리말.M버퍼설정(머리말_임시저장공간)

	var 자료Bytes [4096]byte = *(*[4096]byte)(Pointer(p_자료))
	for i:=0; i<int(크기); i++ {
		임시저장공간[int(사용자규약_머리글_크기)+i] = 자료Bytes[i]
	}

	var 자료주소 uintptr = uintptr(Pointer(&임시저장공간))
	

	자신.T인터넷규약_처리기.M패킷보내기(소켓.원격아이피_주소, 0x11, 자료주소, 전체길이)
	
}
func (자신 *T사용자데이터그램프로토콜_제공자) M결합하기(소켓 *T사용자데이터그램프로토콜_소켓, 처리기 *T사용자데이터그램프로토콜_처리기){
	소켓.P사용자데이터그램프로토콜_처리기 = 처리기
}
