package amd_am79c973

import . "unsafe"
import . "util"
import . "interrupt"
import . "console"
import . "port"
import . "pci"

////////////////////////////////////////////////////////////////////////////////////////
//
//		Register = 登録器
//
////////////////////////////////////////////////////////////////////////////////////////
var 넷카드端末機 T端末機= T端末機{}
type T初期化区域 struct{
	方式 uint16
	送り緩衝器の数 uint8 // 4bit reserved1, 4bit numSendBuffers
	受入緩衝器の数 uint8 // 4bit reserved2, 4bit 受入緩衝器の数
	物理住所 uint64
	論理住所 uint64
	受信_緩衝器記述子_住所 uintptr
	送信_緩衝器記述子_住所 uintptr
}
type T緩衝器_記述子 struct{
	住所 uint32
	標示たち uint32
	標示たち2 uint32
	活性かどうか uint32
}

type I原始資料_處理器 interface{
	M原始資料を受け取った同時(資料住所 uintptr, 大きさ uint32) bool
	M送信(資料住所 uintptr, 大きさ uint32)
}

var 原始資料_後端部 Tamd_am79c973
type T原始資料_處理器 struct{
}
func (自身 *T原始資料_處理器) M後端部_설정(後端部 Tamd_am79c973){
	原始資料_後端部 = 後端部
}
func (自身 *T原始資料_處理器) M後端部_갖기() Tamd_am79c973{
	return 原始資料_後端部
}
func (自身 *T原始資料_處理器) M原始資料を受け取った同時(資料住所 uintptr, 大きさ uint32) bool{
	return true
}

func (自身 *T原始資料_處理器) M送信(資料住所 uintptr, 大きさ uint32) {
	原始資料_後端部.M送信(資料住所 , 大きさ)
}

// wiki.osdev.org/AMD_PCNET
var 媒体住所_0_入出力ポート Tワード入出力ポート 	// MAC0Port
var 媒体住所_2_入出力ポート Tワード入出力ポート 	//
var 媒体住所_4_入出力ポート Tワード入出力ポート
var 登録器資料_入出力ポート Tワード入出力ポート		// registerDataPort(RDP) for CSR(Control and Status register)
var 登録器住所_入出力ポート Tワード入出力ポート		// registerAddressPort(RAP) for CSR
var 再設定_入出力ポート Tワード入出力ポート		// resetPort
var バス制御_登録器資料_入出力ポート Tワード入出力ポート		// busControlRegisterDataPort(BDP)

var 初期化区域 T初期化区域

var 送信_緩衝器_記述子 [8]T緩衝器_記述子		// send buffer descriptor 
var 送信_緩衝器_記述子_主記憶空間 [2048+15] byte
var 送信_緩衝器 [2*1024+15][8] uint8
var 現在送る緩衝器_番号 uint8

var 受信_緩衝器_記述子 [8]T緩衝器_記述子		//received buffer descriptor
var 受信_緩衝器_記述子_主記憶空間 [2048+15] uint8	// received buffers descriptor memrory
var 受信_緩衝器[2*1024+15][8] uint8
var 現在の受信緩衝器_番号 uint8
var 関数変数 func(*Tamd_am79c973, uint32) uint32

type Tamd_am79c973 struct {
	T割り込み_處理器
	周辺部品連結装置の識別子 T周辺部品連結装置の識別子
	割り込み_管理者 *T割り込み_管理者
	原始資料_處理器 *T原始資料_處理器
}
var 端末機 T端末機 = T端末機{}
var i原始資料_處理器 I原始資料_處理器 
func (自身 *Tamd_am79c973) M初期化(割り込み_管理者 *T割り込み_管理者, 
					周辺部品連結装置の識別子 T周辺部品連結装置の識別子, 
					原始資料_處理器 I原始資料_處理器) {
	
	自身.周辺部品連結装置の識別子 = 周辺部品連結装置の識別子
	

        関数変数 = (*Tamd_am79c973).割り込み処理する
        var 関数変数_住所 uintptr
        関数変数_住所 = uintptr(Pointer(&関数変数))


	自身.T割り込み_處理器.M初期化(uint8(0x20+周辺部品連結装置の識別子.P割り込み), uintptr(Pointer(割り込み_管理者)), 関数変数_住所)

	媒体住所_0_入出力ポート.M初期化(uint16(周辺部品連結装置の識別子.P入出力ポート基準))
	媒体住所_2_入出力ポート.M初期化(uint16(周辺部品連結装置の識別子.P入出力ポート基準) + 0x02)
	媒体住所_4_入出力ポート.M初期化(uint16(周辺部品連結装置の識別子.P入出力ポート基準) + 0x04)
	登録器資料_入出力ポート.M初期化(uint16(周辺部品連結装置の識別子.P入出力ポート基準) + 0x10)
	登録器住所_入出力ポート.M初期化(uint16(周辺部品連結装置の識別子.P入出力ポート基準) + 0x12)
	再設定_入出力ポート.M初期化(uint16(周辺部品連結装置の識別子.P入出力ポート基準) + 0x14)
	バス制御_登録器資料_入出力ポート.M初期化(uint16(周辺部品連結装置の識別子.P入出力ポート基準) + 0x16)


	i原始資料_處理器 = &T原始資料_處理器{}	
	if 原始資料_處理器 != nil {
		i原始資料_處理器 = 原始資料_處理器
	}

	現在送る緩衝器_番号 = 0
	現在の受信緩衝器_番号 = 0

	var 媒体0 uint64 =  uint64(媒体住所_0_入出力ポート.M読み取り()%256)
	var 媒体1 uint64 =  uint64(媒体住所_0_入出力ポート.M読み取り()/256)
	var 媒体2 uint64 =  uint64(媒体住所_2_入出力ポート.M読み取り()%256)	
	var 媒体3 uint64 =  uint64(媒体住所_2_入出力ポート.M読み取り()/256)	
	var 媒体4 uint64 =  uint64(媒体住所_4_入出力ポート.M読み取り()%256)	
	var 媒体5 uint64 =  uint64(媒体住所_4_入出力ポート.M読み取り()/256)	

	var 媒体住所 uint64 = (媒体5 << 40) | (媒体4 << 32) | (媒体3 << 24) | (媒体2 << 16) | (媒体1 << 8) | 媒体0
	
	端末機.M出力("[interrupt num : ", 0, 13)
	端末機.M出力(uint8(周辺部品連結装置の識別子.P割り込み))
	端末機.M出力("]")
	端末機.M出力("[MAC : ")
	端末機.MUint48出力(Uint48_R(媒体住所))
	端末機.M出力("]")


	登録器住所_入出力ポート.M作成(20)
	バス制御_登録器資料_入出力ポート.M作成(0x102)

	登録器住所_入出力ポート.M作成(0)
	登録器資料_入出力ポート.M作成(0x04)

	初期化区域.方式 = 0x0000
	初期化区域.送り緩衝器の数 = 3
	初期化区域.受入緩衝器の数 = 3

	初期化区域.物理住所 = 媒体住所

	初期化区域.論理住所 = 0

	送信_緩衝器_記述子 = *(*([8]T緩衝器_記述子))(Pointer((uintptr((Pointer)(&送信_緩衝器_記述子_主記憶空間))+15) & ^(uintptr)(0xF)))
	初期化区域.送信_緩衝器記述子_住所 = uintptr(Pointer(&送信_緩衝器_記述子))
	受信_緩衝器_記述子 = *(*([8]T緩衝器_記述子))(Pointer((uintptr((Pointer)(&受信_緩衝器_記述子_主記憶空間))+15) & ^(uintptr)(0xF)))
	初期化区域.受信_緩衝器記述子_住所 = uintptr(Pointer(&受信_緩衝器_記述子))

	

	for i:=0; i<8; i++ {
		送信_緩衝器_記述子[i].住所 = uint32((uintptr(Pointer(&送信_緩衝器[i])) + 15) & ^(uintptr(0xF))) 
		送信_緩衝器_記述子[i].標示たち = 0x7FF | 0xF000
		送信_緩衝器_記述子[i].標示たち2 = 0
		送信_緩衝器_記述子[i].活性かどうか = 0

		受信_緩衝器_記述子[i].住所 = uint32((uintptr(Pointer(&受信_緩衝器[i])) + 15) & ^(uintptr(0xF)))
		受信_緩衝器_記述子[i].標示たち = 0xF7FF | 0x80000000
	
	}

	登録器住所_入出力ポート.M作成(1)
	登録器資料_入出力ポート.M作成(uint16(uintptr(Pointer(&初期化区域))  & 0xFFFF ))

	登録器住所_入出力ポート.M作成(2)
	登録器資料_入出力ポート.M作成(uint16((uintptr(Pointer(&初期化区域)) >> 16) & 0xFFFF))

}
func (自身 *Tamd_am79c973) M活性化(){
        登録器住所_入出力ポート.M作成(0)
        登録器資料_入出力ポート.M作成(0x41)

        登録器住所_入出力ポート.M作成(4)
        臨時 := 登録器資料_入出力ポート.M読み取り()
	登録器住所_入出力ポート.M作成(4)
	登録器資料_入出力ポート.M作成(臨時 | 0xC00)

	登録器住所_入出力ポート.M作成(0)
	登録器資料_入出力ポート.M作成(0x42)

}
func (自身 *Tamd_am79c973) M再設定() int{
	再設定_入出力ポート.M読み取り()	
	再設定_入出力ポート.M作成(0)
	return 10
}
func (自身 *Tamd_am79c973) 割り込み処理する(esp uint32) uint32{

	登録器住所_入出力ポート.M作成(0)
	臨時 := uint32(登録器資料_入出力ポート.M読み取り())

	if (臨時 & 0x8000) == 0x8000 {
		端末機.M出力("am79c973 error")
	}
	if (臨時 & 0x2000) == 0x2000 {
		端末機.M出力("am79c973 collision error")
	}
	if (臨時 & 0x1000) == 0x1000 {
		端末機.M出力("am79c973 missed frame")
	}
	if (臨時 & 0x0800) == 0x0800 {
		端末機.M出力("am79c973 memory error")
	}
	if (臨時 & 0x0400) == 0x0400 {
		//端末機.M出力("am79c973 data received")
		自身.M受信()
	}
	if (臨時 & 0x0200) == 0x0200 {
		//端末機.M出力("am79c973 data sent")
	}

	// ack	
	登録器住所_入出力ポート.M作成(0)
	登録器資料_入出力ポート.M作成(uint16(臨時))

	if (臨時 & 0x0100) == 0x0100 {
		端末機.M出力("[netcard(am79c973) init done]")
	}
	return esp
}

func (自身 *Tamd_am79c973) M送信(資料住所 uintptr, 大きさ uint32){
	var 送信_緩衝器_番号 uint16 = uint16(現在送る緩衝器_番号)
	現在送る緩衝器_番号 = 0
	if(大きさ > 1518) {
		大きさ = 1518
	}
	
	var 原本資料 [4096] byte = *(*([4096]byte))(Pointer(資料住所))
	var 複写位置 uint32=送信_緩衝器_記述子[送信_緩衝器_番号].住所 + 大きさ -1
	for i:=0; i<int(大きさ); i++{
		*(*byte)(Pointer(uintptr(複写位置))) = 原本資料[int(大きさ)-i-1]
		複写位置--
	}


	var 資料 [4096] byte = *(*([4096]byte))(Pointer(資料住所))
	端末機.M出力("send packet", 0, 2)
	for i:=0; i<64; i++{
		端末機.MHex出力(資料[i])
		端末機.M出力(":")
	}
	端末機.M出力("\n")


	送信_緩衝器_記述子[送信_緩衝器_番号].活性かどうか = 0
	送信_緩衝器_記述子[送信_緩衝器_番号].標示たち2 = 0
	送信_緩衝器_記述子[送信_緩衝器_番号].標示たち = 0x8300F000 | uint32((-大きさ) & 0xFFF)
	

	登録器住所_入出力ポート.M作成(0)
	登録器資料_入出力ポート.M作成(0x48)
}
func (自身 *Tamd_am79c973) M受信(){

	現在の受信緩衝器_番号 = 0

	for ; (受信_緩衝器_記述子[現在の受信緩衝器_番号].標示たち & 0x80000000)==0; 現在の受信緩衝器_番号=(現在の受信緩衝器_番号+1)%8 {
		if !(受信_緩衝器_記述子[現在の受信緩衝器_番号].標示たち & 0x40000000 != 0) &&
		   ((受信_緩衝器_記述子[現在の受信緩衝器_番号].標示たち & 0x03000000) == 0x03000000) {

			var 大きさ uint32 = 受信_緩衝器_記述子[現在の受信緩衝器_番号].標示たち & 0xFFF
			if 大きさ > 64 { // remove checksum
				大きさ -= 4
			}

			var 緩衝器 [4096]byte= *(*([4096]byte))(Pointer(uintptr(受信_緩衝器_記述子[現在の受信緩衝器_番号].住所)))
			var 住所 uintptr = uintptr(Pointer(&緩衝器))
			if i原始資料_處理器 != nil {
				if i原始資料_處理器.M原始資料を受け取った同時(住所, 大きさ) {
					var 住所 uintptr = uintptr(Pointer(&緩衝器))
					自身.M送信(住所, 大きさ)
				}
			}

			var 資料[4096] byte = *(*([4096]byte))(Pointer(&緩衝器))
			端末機.M出力("recv packet", 0, 6)
			for i:=0; i<64; i++{
				端末機.MHex出力(資料[i])
				端末機.M出力(":")
			}
			端末機.M出力("\n")

		}
		受信_緩衝器_記述子[現在の受信緩衝器_番号].標示たち2=0
		受信_緩衝器_記述子[現在の受信緩衝器_番号].標示たち=0x8000F7FF 
	}
}
func (自身 *Tamd_am79c973)M處理器を設定(原始資料_處理器 *T原始資料_處理器){
	自身.原始資料_處理器 = 原始資料_處理器
}
func (自身 *Tamd_am79c973)M媒体住所を取得する() uint64{
	return 初期化区域.物理住所
}
func (自身 *Tamd_am79c973)M論理住所を設定(論理住所 uint64){
	初期化区域.論理住所 = 論理住所
}
func (自身 *Tamd_am79c973)M論理住所を取得する() uint64{
	return 初期化区域.論理住所
}
