package mouse

import . "unsafe"

import . "port"
import . "interrupt"

type Iマウス事件處理器 interface {
        Mマウス押し同時(ボタン int8)
        Mマウス離し同時(ボタン int8)
        Mマウス動かし同時(x int8, y int8)
}
type Tマウス_駆動装置_データ struct{
	
	関数ポインター func(*Tマウス_駆動装置, uint32) uint32

	データ入出力ポート 		Tバイト入出力ポート
	命令語入出力ポート 		Tバイト入出力ポート

	iマウス事件處理器  Iマウス事件處理器

	臨時ボタン値 [3] int8
	要所位置 uint8
	マウスボタン int8
}
var データ Tマウス_駆動装置_データ

type Tマウス_駆動装置 struct{
	*T割り込み_處理器
}

var 命令語入出力ポート Tバイト入出力ポート

func (自身 *Tマウス_駆動装置) M初期化(割り込み_管理者 *T割り込み_管理者, マウス事件處理器 Iマウス事件處理器) {

	データ.iマウス事件處理器 = T基本マウス事件處理器{}
	if マウス事件處理器 != nil {
		データ.iマウス事件處理器 = マウス事件處理器
	}
	データ.関数ポインター = (*Tマウス_駆動装置).割り込み処理
	var 住所 uintptr
	住所 = uintptr(Pointer(&データ.関数ポインター))
	自身.T割り込み_處理器.M初期化(0x2C, uintptr(Pointer(割り込み_管理者)), 住所)

	データ.データ入出力ポート.M初期化(0x60)
	データ.命令語入出力ポート.M初期化(0x64)

	データ.命令語入出力ポート.M作成(0xA8)
	データ.命令語入出力ポート.M作成(0x20)

	
	データ.命令語入出力ポート.M作成(0x60)

	var 状態 uint8
	状態 = (uint8(データ.データ入出力ポート.M読み取り()) | 2 )
	データ.データ入出力ポート.M作成(状態) 
	
	データ.命令語入出力ポート.M作成(0xD4) 
	データ.データ入出力ポート.M作成(0xF4) 

	データ.データ入出力ポート.M読み取り()

}

func (自身 *Tマウス_駆動装置) 割り込み処理(esp uint32) uint32{

	データ.臨時ボタン値[データ.要所位置] = (int8)(データ.データ入出力ポート.M読み取り())
	データ.要所位置 = (データ.要所位置 + 1) % 3

	if データ.要所位置 == 0{
	
		x := データ.臨時ボタン値[1]
		y := データ.臨時ボタン値[2]

		データ.iマウス事件處理器.Mマウス動かし同時(x, y)

		var i uint8=0
		for i=0 ; i<3 ; i++ {
			if (データ.臨時ボタン値[0] & (0x1<<i)) != (データ.マウスボタン & (0x1<<i)) {
				if (データ.マウスボタン & (0x1<<i)) == 0{
					データ.iマウス事件處理器.Mマウス押し同時(データ.臨時ボタン値[0])
				}
			}
		}
		データ.マウスボタン = データ.臨時ボタン値[0]
		
	}

	return esp
}

