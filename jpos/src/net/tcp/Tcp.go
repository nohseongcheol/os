package  伝送制御プロトコル

import . "unsafe"
import . "util"
import . "memorymanager"
import . "net/ipv4" 

//////////////////////////////////////////////////////////////////////////
//
//	TCP = Transmission Control Protocol = 伝送制御プロトコル
//	Socket = ソケット
//	PortNumber = ポート番号
//	Client = クライアント
//	Server = サーバー
//
//////////////////////////////////////////////////////////////////////////

const (
	CLOSED uint8 = 1
	LISTEN uint8 = 2
	SYN_SENT uint8 = 3
	SYN_RECEIVED uint8 = 4

	ESTABLISHED uint8 = 5

	FIN_WAIT1 uint8 = 6
	FIN_WAIT2 uint8 = 7
	CLOSING uint8 = 8
	TIME_WAIT uint8 = 9

	CLOSE_WAIT uint8 = 10
)
type TCPFlags byte
const (
	FIN  TCPFlags = 1
	SYN  TCPFlags = 2
	RST  TCPFlags = 4
	PSH  TCPFlags = 8
	ACK  TCPFlags = 16
	URG  TCPFlags = 32
	/*
	ECE  TCPFlags = 64
	CWR  TCPFlags = 128
	NS  TCPFlags = 256
	*/
)


type T伝送制御プロトコル_頭文字_緩衝器 struct{
	送り元ポート番号 [2]byte	// source port number
	宛先ポート番号 [2]byte		// destination port number
	シーケンス番号 [4] byte		// sequence number
	確認応答番号 [4] byte		// acknowledge number

	頭文字大きさ byte		// header size
	フラグ byte			// flags
	
	ウインドウ [2] byte		// window size
	チェックサム [2] byte		// checksum
	緊急ポインタ [2] byte		// urgent pointer

	オプション [4] byte		// options
}
var 伝送制御プロトコル_頭文字_大きさ uint16 = uint16(Sizeof(T伝送制御プロトコル_頭文字_緩衝器{}))
type T伝送制御プロトコル_頭文字 struct{
	送り元ポート番号 uint16		// source port number
	宛先ポート番号 uint16		// destination port number
	シーケンス番号 uint32		// sequence number
	確認応答番号 uint32		// acknowledge number
	
	頭文字大きさ uint8		// header size
	フラグ uint8			// flasgs

	ウインドウ uint16		// window size
	チェックサム uint16		// checksum
	緊急ポインタ uint16		// urgent pointer
	
	オプション uint32		// options
}
func (自身 *T伝送制御プロトコル_頭文字)M初期化(緩衝器 *T伝送制御プロトコル_頭文字_緩衝器){
	自身.送り元ポート番号 = ArrayToUint16(緩衝器.送り元ポート番号)
	自身.宛先ポート番号 = ArrayToUint16(緩衝器.宛先ポート番号)
	自身.シーケンス番号 = ArrayToUint32(緩衝器.シーケンス番号)
	自身.確認応答番号 = ArrayToUint32(緩衝器.確認応答番号)

	自身.頭文字大きさ = 緩衝器.頭文字大きさ
	自身.フラグ = 緩衝器.フラグ

	自身.ウインドウ = ArrayToUint16(緩衝器.ウインドウ)
	自身.チェックサム = ArrayToUint16(緩衝器.チェックサム)
	自身.緊急ポインタ = ArrayToUint16(緩衝器.緊急ポインタ)

	自身.オプション = ArrayToUint32(緩衝器.オプション)
}
func (自身 *T伝送制御プロトコル_頭文字)M緩衝器_設定(緩衝器 *T伝送制御プロトコル_頭文字_緩衝器){
	緩衝器.送り元ポート番号 = Uint16ToArray(自身.送り元ポート番号)
	緩衝器.宛先ポート番号 = Uint16ToArray(自身.宛先ポート番号)
	緩衝器.シーケンス番号 = Uint32ToArray(自身.シーケンス番号)
	緩衝器.確認応答番号 = Uint32ToArray(自身.確認応答番号)

	緩衝器.頭文字大きさ = 自身.頭文字大きさ
	緩衝器.フラグ = 自身.フラグ

	緩衝器.ウインドウ = Uint16ToArray(自身.ウインドウ)
	緩衝器.チェックサム = Uint16ToArray(自身.チェックサム)
	緩衝器.緊急ポインタ = Uint16ToArray(自身.緊急ポインタ)

	緩衝器.オプション = Uint32ToArray(自身.オプション)
}

type 伝送制御プロトコル_類似_頭文字_緩衝器 struct{
	送信元アイピー住所 [4] byte	// source ip address
	宛先アイピー住所 [4] byte	// destination ip address
	プロトコル [2] byte			// protocol
	全体の長さ [2] byte		// total length
}
var 伝送制御プロトコル_類似_頭文字_大きさ uint16 = uint16(Sizeof(伝送制御プロトコル_類似_頭文字_緩衝器{}))
type 伝送制御プロトコル_類似_頭文字 struct{
	送信元アイピー住所 uint32	// source ip address
	宛先アイピー住所 uint32		// destination ip address
	プロトコル uint16			// protocol
	全体の長さ uint16		// total length
}
func (自身 *伝送制御プロトコル_類似_頭文字) M初期化(緩衝器 *伝送制御プロトコル_類似_頭文字_緩衝器){
	自身.送信元アイピー住所 = ArrayToUint32(緩衝器.送信元アイピー住所)
	自身.宛先アイピー住所 = ArrayToUint32(緩衝器.宛先アイピー住所)
	自身.プロトコル = ArrayToUint16(緩衝器.プロトコル)
	自身.全体の長さ = ArrayToUint16(緩衝器.全体の長さ)
}
func (自身 *伝送制御プロトコル_類似_頭文字) M緩衝器_設定(緩衝器 *伝送制御プロトコル_類似_頭文字_緩衝器){
	緩衝器.送信元アイピー住所 = Uint32ToArray(自身.送信元アイピー住所)
	緩衝器.宛先アイピー住所 = Uint32ToArray(自身.宛先アイピー住所)
	緩衝器.プロトコル = Uint16ToArray(自身.プロトコル)
	緩衝器.全体の長さ = Uint16ToArray(自身.全体の長さ)
}

////////////////////////////////////////////////////////////////////////////////////
type Iクライアント_伝送制御プロトコル_處理器 interface{
	M連結成立同時(ソケット *T伝送制御プロトコル_ソケット)
	M資料を受信と同時(資料 []byte, 大きさ uint32)
}
type Tクライアント_伝送制御プロトコル_處理器 struct{
}
func (自身 *Tクライアント_伝送制御プロトコル_處理器) M連結成立同時(ソケット *T伝送制御プロトコル_ソケット){
}
func (自身 *Tクライアント_伝送制御プロトコル_處理器) M資料を受信と同時(資料 []byte, 大きさ uint32){
}

type Iサーバ_伝送制御プロトコル_處理器 interface{
	M連結成立同時(ソケット *T伝送制御プロトコル_ソケット)
	M資料を受信と同時(資料 []byte, 大きさ uint32)
}
type Tサーバ_伝送制御プロトコル_處理器 struct{
}
func (自身 *Tサーバ_伝送制御プロトコル_處理器) M連結成立同時(ソケット *T伝送制御プロトコル_ソケット){
}
func (自身 *Tサーバ_伝送制御プロトコル_處理器) M資料を受信と同時(資料 []byte, 大きさ uint32){
}
////////////////////////////////////////////////////////////////////////////////////
type T伝送制御プロトコル_處理器 struct{
}
func (自身 *T伝送制御プロトコル_處理器) M伝送制御プロトコル_メッセージ_處理器(ソケット *T伝送制御プロトコル_ソケット, 資料 uintptr, 大きさ uint16) bool{
	return true
}

////////////////////////////////////////////////////////////////////////////////////
type T伝送制御プロトコル_ソケット struct{
	遠隔ポート番号 uint16
	遠隔アイピー住所 uint32
	自身ポート番号 uint16
	自身アイピー住所 uint32
	シーケンス番号 uint32
	確認応答番号 uint32

	後端部 *T伝送制御プロトコル_提供者
	處理器 *T伝送制御プロトコル_處理器

	状態 uint8

}
var ソケット資料 T伝送制御プロトコル_ソケット
func (自身 *T伝送制御プロトコル_ソケット) M初期化(後端部 *T伝送制御プロトコル_提供者){
	自身.後端部 = 後端部
	自身.處理器 = nil
	自身.状態 = CLOSED
}
func (自身 *T伝送制御プロトコル_ソケット) M伝送制御プロトコル_メッセージ_處理器(資料 uintptr, 大きさ uint16) bool{
	if 自身.處理器 != nil {
		return 自身.處理器.M伝送制御プロトコル_メッセージ_處理器(自身, 資料, 大きさ)
	}
	return false
}
func (自身 *T伝送制御プロトコル_ソケット) M送信(資料 []byte, 大きさ uint16){

	var 주소 = uintptr(Pointer(&資料))
	自身.後端部.M送信(自身, 주소, 大きさ, uint16(PSH|ACK))
}
func (自身 *T伝送制御プロトコル_ソケット) M切断する(){
	自身.後端部.M切断する(自身)
}
////////////////////////////////////////////////////////////////////////////////////
type T伝送制御プロトコル_提供者_資料 struct{
	ソケット [65535] *T伝送制御プロトコル_ソケット
	ソケット数 uint16
	余裕ポート番号 uint16
	
	伝送制御プロトコル_處理器 T伝送制御プロトコル_處理器
	クライアント_伝送制御プロトコル_處理器 Iクライアント_伝送制御プロトコル_處理器
	サーバ_伝送制御プロトコル_處理器 Iサーバ_伝送制御プロトコル_處理器
	
}
var 資料 T伝送制御プロトコル_提供者_資料

type T伝送制御プロトコル_提供者 struct{
	Tインターネットプロトコル_處理器
}
func (自身 *T伝送制御プロトコル_提供者) M初期化(後端部 Tインターネットプロトコル_提供者, クライアント_伝送制御プロトコル_處理器 Iクライアント_伝送制御プロトコル_處理器){

	if クライアント_伝送制御プロトコル_處理器 != nil {
		資料.クライアント_伝送制御プロトコル_處理器 = クライアント_伝送制御プロトコル_處理器
	} else{
		資料.クライアント_伝送制御プロトコル_處理器 = &Tクライアント_伝送制御プロトコル_處理器{}	
	}

	自身.Tインターネットプロトコル_處理器.M初期化(後端部, 自身, 0x06)
	資料.クライアント_伝送制御プロトコル_處理器 = クライアント_伝送制御プロトコル_處理器
	for i:=0; i<65535; i++{
		資料.ソケット[i] = nil
	}
	資料.ソケット数 = 0
	資料.余裕ポート番号 = 1024

}
func (自身 *T伝送制御プロトコル_提供者) Mインターネットプロトコル_受信と同時(送信元アイピー住所_BE uint32, 宛先アイピー住所_BE uint32, IP搭載資料 uintptr, 大きさ uint32) bool{
	if 大きさ < 20{
		return false
	}

	var メッセージ_緩衝器 = (*T伝送制御プロトコル_頭文字_緩衝器)(Pointer(IP搭載資料))
	var メッセージ = T伝送制御プロトコル_頭文字{}
	メッセージ.M初期化(メッセージ_緩衝器)
	

	var ソケット  *T伝送制御プロトコル_ソケット = nil

	var i = 0	
	for i=0; i<int(資料.ソケット数) && ソケット == nil; i++ {
		if 資料.ソケット[i].自身ポート番号 == Uint16_R(メッセージ.宛先ポート番号) &&
			資料.ソケット[i].自身アイピー住所 == 宛先アイピー住所_BE &&
			資料.ソケット[i].状態 == LISTEN &&
			//((TCPFlags(メッセージ.フラグ) & (SYN | ACK)) == SYN) {
			((メッセージ.フラグ & uint8(SYN | ACK)) == uint8(SYN)) {
				ソケット = 資料.ソケット[i]
		}else if 資料.ソケット[i].自身ポート番号 == Uint16_R(メッセージ.宛先ポート番号) &&
			資料.ソケット[i].自身アイピー住所 == 宛先アイピー住所_BE &&
			資料.ソケット[i].遠隔ポート番号 == Uint16_R(メッセージ.送り元ポート番号) &&
			資料.ソケット[i].遠隔アイピー住所 == 送信元アイピー住所_BE {
				ソケット = 資料.ソケット[i]
		}
	
	}
	

	var 再設定 = false
	
	if ソケット != nil && ((メッセージ.フラグ & uint8(RST)) != 0) {
		ソケット.状態 = CLOSED
	}


	if ソケット != nil && ソケット.状態 != CLOSED {
		//switch TCPFlags(メッセージ.フラグ) & (SYN | ACK | FIN) {
		switch メッセージ.フラグ {
		case uint8(SYN):
			if ソケット.状態 == LISTEN {
				ソケット.状態 = SYN_RECEIVED
				ソケット.遠隔ポート番号 = Uint16_R(メッセージ.送り元ポート番号)
				ソケット.遠隔アイピー住所 = 送信元アイピー住所_BE
				ソケット.確認応答番号 = メッセージ.シーケンス番号 + 1
				ソケット.シーケンス番号 = 0xbeefcafe

				自身.M送信(ソケット, 0, 0, uint16(SYN|ACK))
				ソケット.シーケンス番号++

			}else{
				再設定 = true
			}

		case uint8(SYN | ACK):
			if ソケット.状態 == SYN_SENT {
				ソケット.状態 = ESTABLISHED
				ソケット.確認応答番号 = メッセージ.シーケンス番号 + 1
				ソケット.シーケンス番号++
				自身.M送信(ソケット, 0, 0, uint16(ACK))
			
				資料.クライアント_伝送制御プロトコル_處理器.M連結成立同時(ソケット)

			}else{
				再設定 = true
			}

		case uint8(SYN | FIN) :
			fallthrough
		case uint8(SYN | FIN | ACK) :
			再設定 = true

		case uint8(FIN):
			fallthrough
		case uint8(FIN | ACK):
			if ソケット.状態 == ESTABLISHED {
				ソケット.状態 = CLOSE_WAIT
				ソケット.確認応答番号++
				自身.M送信(ソケット, 0, 0, uint16(ACK))
				自身.M送信(ソケット, 0, 0, uint16(FIN|ACK))
			}else if ソケット.状態 == CLOSE_WAIT {
				ソケット.状態 = CLOSED
			}else if ソケット.状態 == FIN_WAIT1 || 
					ソケット.状態 == FIN_WAIT2 {
				ソケット.状態 = CLOSED
				ソケット.確認応答番号++
				自身.M送信(ソケット, 0, 0, uint16(ACK))
			}else{
				再設定 = true
			}

		case uint8(ACK):

			if ソケット.状態 == SYN_RECEIVED {
				ソケット.状態 = ESTABLISHED
				資料.サーバ_伝送制御プロトコル_處理器.M連結成立同時(ソケット)
				return false
			}else if ソケット.状態 == FIN_WAIT1 {
				ソケット.状態 = FIN_WAIT2
				return false
			}else if ソケット.状態 == CLOSE_WAIT {
				ソケット.状態 = CLOSED
				break
			}

			if TCPFlags(メッセージ.フラグ) == ACK {
				break
			}
			fallthrough
		default:
			if メッセージ.シーケンス番号 == ソケット.確認応答番号 {
				再設定 = !(ソケット.M伝送制御プロトコル_メッセージ_處理器(IP搭載資料 + uintptr(メッセージ.頭文字大きさ*4), uint16(大きさ-uint32(メッセージ.頭文字大きさ*4))))
				if !再設定 {
					var x uint8 = 0
					var 搭載バイト []byte = *(*[]byte)(Pointer(IP搭載資料))
					資料.クライアント_伝送制御プロトコル_處理器.M資料を受信と同時(搭載バイト, 大きさ)
					資料.サーバ_伝送制御プロトコル_處理器.M資料を受信と同時(搭載バイト, 大きさ)
					for i:=int(メッセージ.頭文字大きさ*4); i<int(大きさ); i++{
						if 搭載バイト[i] != 0 {
							x = uint8(i)
						}
					}
					ソケット.確認応答番号 += uint32(x - メッセージ.頭文字大きさ*4 + 1)
					自身.M送信(ソケット, 0, 0, uint16(ACK))
				}else{
					再設定 = true
				}

			}
		}

	}
	if 再設定 {
		if ソケット != nil {
			自身.M送信(ソケット, 0, 0, uint16(RST))
		}else{
			var ソケット T伝送制御プロトコル_ソケット
			ソケット.遠隔ポート番号 = メッセージ.送り元ポート番号
			ソケット.遠隔アイピー住所 = 送信元アイピー住所_BE
			ソケット.自身ポート番号 = メッセージ.宛先ポート番号
			ソケット.自身アイピー住所 = 宛先アイピー住所_BE
			ソケット.シーケンス番号 = Uint32_R(メッセージ.確認応答番号)
			ソケット.確認応答番号 = Uint32_R(メッセージ.シーケンス番号) + 1
			自身.M送信(&ソケット, 0, 0, uint16(RST))
		}
	}

	if ソケット != nil && ソケット.状態 == CLOSED {
		for i:=0; i<int(資料.ソケット数) && ソケット == nil; i++ {
			if 資料.ソケット[i] == ソケット {
				資料.ソケット数--
				資料.ソケット[i] = 資料.ソケット[資料.ソケット数]
				break
			}
		}
	}

	return false
}
func (自身 *T伝送制御プロトコル_提供者) M送信(ソケット *T伝送制御プロトコル_ソケット, 資料 uintptr, 大きさ uint16, フラグ uint16){
	
	var 全体の長さ = 大きさ + 伝送制御プロトコル_頭文字_大きさ
	var lengthInclPHdr = 全体の長さ + 伝送制御プロトコル_類似_頭文字_大きさ

	var 緩衝器 [4096]byte

	var 類似頭文字_緩衝器 = (*伝送制御プロトコル_類似_頭文字_緩衝器)(Pointer(&緩衝器))
	var メッセージ_緩衝器 = (*T伝送制御プロトコル_頭文字_緩衝器)(Pointer(&緩衝器[伝送制御プロトコル_類似_頭文字_大きさ]))
	

	var メッセージ = T伝送制御プロトコル_頭文字{}
	メッセージ.頭文字大きさ = uint8(伝送制御プロトコル_頭文字_大きさ/4) << 4
	メッセージ.送り元ポート番号 = ソケット.自身ポート番号
	メッセージ.宛先ポート番号 = ソケット.遠隔ポート番号

	メッセージ.確認応答番号 = Uint32_R(ソケット.確認応答番号)
	メッセージ.シーケンス番号 = Uint32_R(ソケット.シーケンス番号)
	メッセージ.フラグ = uint8(フラグ & 0x00FF)
	メッセージ.ウインドウ = 0xFFFF
	メッセージ.緊急ポインタ = 0


	if (TCPFlags(フラグ) & SYN) != 0 {
		メッセージ.オプション = 0xB4050402
	}else{
		メッセージ.オプション = 0
	}

	ソケット.シーケンス番号 += uint32(大きさ)

	var 資料バイト = *(*[]byte)(Pointer(資料))
	for i:=0; i<int(大きさ); i++{
		緩衝器[int(伝送制御プロトコル_頭文字_大きさ+伝送制御プロトコル_類似_頭文字_大きさ)+i] = 資料バイト[i]
	}

	var 類似_頭文字 = 伝送制御プロトコル_類似_頭文字{}

	類似_頭文字.送信元アイピー住所 = ソケット.自身アイピー住所
	類似_頭文字.宛先アイピー住所 = ソケット.遠隔アイピー住所
	類似_頭文字.プロトコル = 0x0600
	類似_頭文字.全体の長さ = Uint16_R(全体の長さ)
	類似_頭文字.M緩衝器_設定(類似頭文字_緩衝器)

	メッセージ.チェックサム = 0
	メッセージ.M緩衝器_設定(メッセージ_緩衝器)
	メッセージ.チェックサム = 自身.Tインターネットプロトコル_處理器.M提供者を得る().M検査合計((*([4096]uint16))(Pointer(&緩衝器)), uint32(lengthInclPHdr))
	メッセージ.M緩衝器_設定(メッセージ_緩衝器)
	var 資料住所 = uintptr(Pointer(メッセージ_緩衝器))


	自身.Tインターネットプロトコル_處理器.Mパケット送信(ソケット.遠隔アイピー住所, 0x06, 資料住所, uint32(全体の長さ))
}
func (自身 *T伝送制御プロトコル_提供者) M接続する(アイピー住所 uint32, ポート番号 uint16) *T伝送制御プロトコル_ソケット{
	var memoryManager = &TMemoryManager{}
	var ソケット = (*T伝送制御プロトコル_ソケット)(memoryManager.Malloc(512))
	
	if ソケット != nil {
		ソケット.M初期化(自身)
		
		ソケット.遠隔ポート番号 = ポート番号
		ソケット.遠隔アイピー住所 = アイピー住所
		ソケット.自身ポート番号 = 資料.余裕ポート番号
		資料.余裕ポート番号++
		ソケット.自身アイピー住所 = uint32(自身.Tインターネットプロトコル_處理器.M提供者を得る().Mアイピー住所を取得する())

		ソケット.遠隔ポート番号 = Uint16_R(ソケット.遠隔ポート番号)
		ソケット.自身ポート番号 = Uint16_R(ソケット.自身ポート番号)

		資料.ソケット[資料.ソケット数] = ソケット
		資料.ソケット数++
	
		ソケット.状態 = SYN_SENT	
		ソケット.シーケンス番号 = 0xbeefcafe
		
		自身.M送信(ソケット, 0, 0, uint16(SYN))

	}
	return ソケット
}
func (自身 *T伝送制御プロトコル_提供者) M切断する(ソケット *T伝送制御プロトコル_ソケット){
	ソケット.状態 = FIN_WAIT1
	自身.M送信(ソケット, 0, 0, uint16(FIN+ACK))
	ソケット.シーケンス番号++
}
func (自身 *T伝送制御プロトコル_提供者) M受信待ち(ポート番号 uint16) *T伝送制御プロトコル_ソケット{
	var memoryManager = &TMemoryManager{}
	var ソケット = (*T伝送制御プロトコル_ソケット)(memoryManager.Malloc(50))

	if ソケット != nil {

		ソケット.M初期化(自身)
	
		ソケット.状態 = LISTEN
		ソケット.自身アイピー住所 = uint32(自身.Tインターネットプロトコル_處理器.M提供者を得る().Mアイピー住所を取得する())
		ソケット.自身ポート番号 = Uint16_R(ポート番号)
		資料.ソケット[資料.ソケット数]  = ソケット
		資料.ソケット数++
	}
	return ソケット
}
func (自身 *T伝送制御プロトコル_提供者) M結合する(ソケット *T伝送制御プロトコル_ソケット, 處理器 Iサーバ_伝送制御プロトコル_處理器){
	if 處理器 != nil{
		資料.サーバ_伝送制御プロトコル_處理器 = 處理器
	}else {
		資料.サーバ_伝送制御プロトコル_處理器 = &Tサーバ_伝送制御プロトコル_處理器{}
	}

}
